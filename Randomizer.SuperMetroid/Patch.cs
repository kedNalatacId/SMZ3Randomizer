using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using System.IO;
using static System.Linq.Enumerable;
using static Randomizer.SuperMetroid.ItemType;
using System.Text.RegularExpressions;

namespace Randomizer.SuperMetroid {
    static class KeycardPlaque {
        public const ushort Level1 = 0xe0;
        public const ushort Level2 = 0xe1;
        public const ushort Boss = 0xe2;
        public const ushort None = 0x00;
    }

    static class KeycardDoors {
        public const ushort Left = 0xd414;
        public const ushort Right = 0xd41a;
        public const ushort Up = 0xd420;
        public const ushort Down = 0xd426;
        public const ushort BossLeft = 0xc842;
        public const ushort BossRight = 0xc848;
    }

    static class KeycardEvents {
        public const ushort CrateriaLevel1 = 0x0000;
        public const ushort CrateriaLevel2 = 0x0100;
        public const ushort CrateriaBoss = 0x0200;
        public const ushort BrinstarLevel1 = 0x0300;
        public const ushort BrinstarLevel2 = 0x0400;
        public const ushort BrinstarBoss = 0x0500;
        public const ushort NorfairLevel1 = 0x0600;
        public const ushort NorfairLevel2 = 0x0700;
        public const ushort NorfairBoss = 0x0800;
        public const ushort MaridiaLevel1 = 0x0900;
        public const ushort MaridiaLevel2 = 0x0a00;
        public const ushort MaridiaBoss = 0x0b00;
        public const ushort WreckedShipLevel1 = 0x0c00;
        public const ushort WreckedShipBoss = 0x0d00;
        public const ushort LowerNorfairLevel1 = 0x0e00;
        public const ushort LowerNorfairBoss = 0x0f00;
    }

    class Patch {
        readonly List<World> allWorlds;
        readonly World myWorld;
        readonly string seedGuid;
        readonly int seed;
        readonly Random rnd;
        List<(int offset, byte[] bytes)> patches;
        // Dictionary<int, byte[]> patches;

        public Patch(World myWorld, List<World> allWorlds, string seedGuid, int seed, Random rnd) {
            this.myWorld = myWorld;
            this.allWorlds = allWorlds;
            this.seedGuid = seedGuid;
            this.seed = seed;
            this.rnd = rnd;
        }

        public Dictionary<int, byte[]> Create() {
            patches = new List<(int, byte[])>();

            WriteLocations(myWorld.Regions.SelectMany(x => x.Locations));
            WriteKeyCardDoors();
            WritePlayerNames();
            WriteSeedData();
            // WriteItemLocations();
            // WriteAnimalSurprise();
            WriteGameTitle();
            WriteGameModeData();
            WriteRngBlock();

            return patches.ToDictionary(x => x.offset, x => x.bytes);
        }

        void WriteRngBlock() {
            /* Repoint RNG Block */
            patches.Add((0x420000, Range(0, 1024).Select(x => (byte)rnd.Next(0x100)).ToArray()));
        }

        private ushort GetSMItemPLM(Location location) {
            int plmId = myWorld.Config.GameMode == GameMode.Multiworld ?
                0xEFE0 :
                location.Item.Type switch {
                    ETank => 0xEED7,
                    Missile => 0xEEDB,
                    Super => 0xEEDF,
                    PowerBomb => 0xEEE3,
                    Bombs => 0xEEE7,
                    Charge => 0xEEEB,
                    Ice => 0xEEEF,
                    HiJump => 0xEEF3,
                    SpeedBooster => 0xEEF7,
                    Wave => 0xEEFB,
                    Spazer => 0xEEFF,
                    SpringBall => 0xEF03,
                    Varia => 0xEF07,
                    Plasma => 0xEF13,
                    Grapple => 0xEF17,
                    Morph => 0xEF23,
                    ReserveTank => 0xEF27,
                    Gravity => 0xEF0B,
                    XRay => 0xEF0F,
                    SpaceJump => 0xEF1B,
                    ScrewAttack => 0xEF1F,
                    _ => 0xEFE0,
                };

            plmId += plmId switch {
                0xEFE0 => location.Type switch {
                    LocationType.Chozo => 4,
                    LocationType.Hidden => 8,
                    _ => 0
                },
                _ => location.Type switch {
                    LocationType.Chozo => 0x54,
                    LocationType.Hidden => 0xA8,
                    _ => 0
                }
            };

            // return BitConverter.GetBytes((ushort)plmId);
            return (ushort)plmId;
        }

        void WriteLocations(IEnumerable<Location> locations) {
            foreach (var location in locations) {
                if (myWorld.Config.GameMode == GameMode.Multiworld) {
                    patches.Add((Snes(location.Address), UshortBytes(GetSMItemPLM(location))));
                    patches.Add(ItemTablePatch(location, (byte)location.Item.Type));
                } else {
                    ushort plmId = GetSMItemPLM(location);
                    patches.Add((Snes(location.Address), UshortBytes(plmId)));
                    if (plmId >= 0xEFE0) {
                        patches.Add((Snes(location.Address + 5), new byte[] { (byte)location.Item.Type }));
                    }
                }
            }
        }

        (int, byte[]) ItemTablePatch(Location location, byte itemId) {
            var type = location.Item.World == location.Region.World ? 0 : 1;
            var owner = location.Item.World.Id;
            return (0x386000 + (location.Id * 8), new[] { type, itemId, owner, 0 }.SelectMany(UshortBytes).ToArray());
        }

        void WritePlayerNames() {
            foreach (var world in allWorlds) {
                patches.Add((0x1C5000 + (world.Id * 16), PlayerNameBytes(world.Player)));
            }
        }

        byte[] PlayerNameBytes(string name) {
            name = name.Length > 12 ? name[..12] : name;
            int padding = 12 - name.Length;
            if (padding > 0) {
                double pad = padding / 2.0;
                name = name.PadLeft(name.Length + (int)Math.Ceiling(pad));
                name = name.PadRight(name.Length + (int)Math.Floor(pad));
            }
            return AsAscii(name).Concat(UintBytes(0)).ToArray();
        }

        void WriteSeedData() {
            var configField =
                ((myWorld.Config.Race ? 1 : 0) << 15) |
                ((myWorld.Config.UseKeycards ? 1 : 0) << 13) |
                ((myWorld.Config.GameMode == GameMode.Multiworld ? 1 : 0) << 12) |
                /* Gap of 2 bits, taken by Z3 logic in combo */
                ((int)myWorld.Config.SMLogic << 8) |
                (Randomizer.version.Major << 4) |
                (Randomizer.version.Minor << 0);

            patches.Add((Snes(0x80FF50), UshortBytes(myWorld.Id)));
            patches.Add((Snes(0x80FF52), UshortBytes(configField)));
            patches.Add((Snes(0x80FF54), UintBytes(seed)));
            // Reserve the rest of the space for future use
            patches.Add((Snes(0x80FF58), Repeat<byte>(0x00, 8).ToArray()));
            patches.Add((Snes(0x80FF60), AsAscii(seedGuid)));
            patches.Add((Snes(0x80FF80), AsAscii(myWorld.Guid)));
        }

        void WriteGameModeData() {
            if (myWorld.Config.GameMode == GameMode.Multiworld) {
                patches.Add((Snes(0xF47000), UshortBytes(0x0001)));
            }
        }

        /* void WriteItemLocations() {
            int romAddress = 0x2F5240;
            foreach (var location in myWorld.Locations.OrderBy(l => l.Region.Name).ThenBy(l => l.Name).Where(l => l.Item.Class == ItemClass.Major)) {
                patches.Add(romAddress, AsCreditsString(0x04, location.Item.Name, true));
                patches.Add(romAddress + 0x40, AsCreditsString(0x18, location.Name, false));
                romAddress += 0x80;
            }

            patches.Add(romAddress, new byte[] { 0, 0, 0, 0 });
        } */

        void WriteGameTitle() {
            var smLogic = myWorld.Config.SMLogic switch
            {
                SMLogic.Normal => "N",
                SMLogic.Medium => "M",
                _ => "H",
            };
            var title = AsAscii($"SM{Randomizer.version}{smLogic}{seed:X8}".PadRight(21)[..21]);
            // patches.Add(0x007FC0, title);
            patches.Add((Snes(0x00FFC0), title));
            patches.Add((Snes(0x80FFC0), title));
        }

        void WriteKeyCardDoors() {
            if (!myWorld.Config.UseKeycards)
                return;

            ushort plaquePLm = 0xd410;

            var doorList = new List<ushort[]> {
                            // RoomId  Door Facing                yyxx  Keycard Event Type                   Plaque type               yyxx, Address (if 0 a dynamic PLM is created)
                // Crateria
                new ushort[] { 0x91F8, KeycardDoors.Right,      0x2601, KeycardEvents.CrateriaLevel1,        KeycardPlaque.Level1,   0x2400, 0x0000 },  // Crateria - Landing Site - Door to gauntlet
                new ushort[] { 0x91F8, KeycardDoors.Left,       0x168E, KeycardEvents.CrateriaLevel1,        KeycardPlaque.Level1,   0x148F, 0x801E },  // Crateria - Landing Site - Door to landing site PB
                new ushort[] { 0x948C, KeycardDoors.Left,       0x062E, KeycardEvents.CrateriaLevel2,        KeycardPlaque.Level2,   0x042F, 0x8222 },  // Crateria - Before Moat - Door to moat (overwrite PB door)
                new ushort[] { 0x99BD, KeycardDoors.Left,       0x660E, KeycardEvents.CrateriaBoss,          KeycardPlaque.Boss,     0x640F, 0x8470 },  // Crateria - Before G4 - Door to G4
                new ushort[] { 0x9879, KeycardDoors.Left,       0x062E, KeycardEvents.CrateriaBoss,          KeycardPlaque.Boss,     0x042F, 0x8420 },  // Crateria - Before BT - Door to Bomb Torizo

                // Brinstar
                new ushort[] { 0x9F11, KeycardDoors.Left,       0x060E, KeycardEvents.BrinstarLevel1,        KeycardPlaque.Level1,   0x040F, 0x8784 },  // Brinstar - Blue Brinstar - Door to ceiling e-tank room

                new ushort[] { 0x9AD9, KeycardDoors.Right,      0xA601, KeycardEvents.BrinstarLevel2,        KeycardPlaque.Level2,   0xA400, 0x0000 },  // Brinstar - Green Brinstar - Door to etecoon area
                new ushort[] { 0x9D9C, KeycardDoors.Down,       0x0336, KeycardEvents.BrinstarBoss,          KeycardPlaque.Boss,     0x0234, 0x863A },  // Brinstar - Pink Brinstar - Door to spore spawn
                new ushort[] { 0xA130, KeycardDoors.Left,       0x161E, KeycardEvents.BrinstarLevel2,        KeycardPlaque.Level2,   0x141F, 0x881C },  // Brinstar - Pink Brinstar - Door to wave gate e-tank
                new ushort[] { 0xA0A4, KeycardDoors.Left,       0x062E, KeycardEvents.BrinstarLevel2,        KeycardPlaque.Level2,   0x042F, 0x0000 },  // Brinstar - Pink Brinstar - Door to spore spawn super

                new ushort[] { 0xA56B, KeycardDoors.Left,       0x161E, KeycardEvents.BrinstarBoss,          KeycardPlaque.Boss,     0x141F, 0x8A1A },  // Brinstar - Before Kraid - Door to Kraid

                // Upper Norfair
                new ushort[] { 0xA7DE, KeycardDoors.Right,      0x3601, KeycardEvents.NorfairLevel1,         KeycardPlaque.Level1,   0x3400, 0x8B00 },  // Norfair - Business Centre - Door towards Ice
                new ushort[] { 0xA923, KeycardDoors.Right,      0x0601, KeycardEvents.NorfairLevel1,         KeycardPlaque.Level1,   0x0400, 0x0000 },  // Norfair - Pre-Crocomire - Door towards Ice

                new ushort[] { 0xA788, KeycardDoors.Left,       0x162E, KeycardEvents.NorfairLevel2,         KeycardPlaque.Level2,   0x142F, 0x8AEA },  // Norfair - Lava Missile Room - Door towards Bubble Mountain
                new ushort[] { 0xAF72, KeycardDoors.Left,       0x061E, KeycardEvents.NorfairLevel2,         KeycardPlaque.Level2,   0x041F, 0x0000 },  // Norfair - After frog speedway - Door to Bubble Mountain
                new ushort[] { 0xAEDF, KeycardDoors.Down,       0x0206, KeycardEvents.NorfairLevel2,         KeycardPlaque.Level2,   0x0204, 0x0000 },  // Norfair - Below bubble mountain - Door to Bubble Mountain
                new ushort[] { 0xAD5E, KeycardDoors.Right,      0x0601, KeycardEvents.NorfairLevel2,         KeycardPlaque.Level2,   0x0400, 0x0000 },  // Norfair - LN Escape - Door to Bubble Mountain

                new ushort[] { 0xA923, KeycardDoors.Up,         0x2DC6, KeycardEvents.NorfairBoss,           KeycardPlaque.Boss,     0x2EC4, 0x8B96 },  // Norfair - Pre-Crocomire - Door to Crocomire

                // Lower Norfair
                new ushort[] { 0xB4AD, KeycardDoors.Left,       0x160E, KeycardEvents.LowerNorfairLevel1,    KeycardPlaque.Level1,   0x140F, 0x0000 },  // Lower Norfair - WRITG - Door to Amphitheatre
                new ushort[] { 0xAD5E, KeycardDoors.Left,       0x065E, KeycardEvents.LowerNorfairLevel1,    KeycardPlaque.Level1,   0x045F, 0x0000 },  // Lower Norfair - Exit - Door to "Reverse LN Entry"
                new ushort[] { 0xB37A, KeycardDoors.Right,      0x0601, KeycardEvents.LowerNorfairBoss,      KeycardPlaque.Boss,     0x0400, 0x8EA6 },  // Lower Norfair - Pre-Ridley - Door to Ridley

                // Maridia
                new ushort[] { 0xD0B9, KeycardDoors.Left,       0x065E, KeycardEvents.MaridiaLevel1,         KeycardPlaque.Level1,   0x045F, 0x0000 },  // Maridia - Mt. Everest - Door to Pink Maridia
                new ushort[] { 0xD5A7, KeycardDoors.Right,      0x1601, KeycardEvents.MaridiaLevel1,         KeycardPlaque.Level1,   0x1400, 0x0000 },  // Maridia - Aqueduct - Door towards Beach

                new ushort[] { 0xD617, KeycardDoors.Left,       0x063E, KeycardEvents.MaridiaLevel2,         KeycardPlaque.Level2,   0x043F, 0x0000 },  // Maridia - Pre-Botwoon - Door to Botwoon
                new ushort[] { 0xD913, KeycardDoors.Right,      0x2601, KeycardEvents.MaridiaLevel2,         KeycardPlaque.Level2,   0x2400, 0x0000 },  // Maridia - Pre-Colloseum - Door to post-botwoon

                new ushort[] { 0xD78F, KeycardDoors.Right,      0x2601, KeycardEvents.MaridiaBoss,           KeycardPlaque.Boss,     0x2400, 0xC73B },  // Maridia - Precious Room - Door to Draygon

                new ushort[] { 0xDA2B, KeycardDoors.BossLeft,   0x164E, 0x00f0, /* Door id 0xf0 */           KeycardPlaque.None,     0x144F, 0x0000 },  // Maridia - Change Cac Alley Door to Boss Door (prevents key breaking)

                // Wrecked Ship
                new ushort[] { 0x93FE, KeycardDoors.Left,       0x167E, KeycardEvents.WreckedShipLevel1,     KeycardPlaque.Level1,   0x147F, 0x0000 },  // Wrecked Ship - Outside Wrecked Ship West - Door to Reserve Tank Check
                new ushort[] { 0x968F, KeycardDoors.Left,       0x060E, KeycardEvents.WreckedShipLevel1,     KeycardPlaque.Level1,   0x040F, 0x0000 },  // Wrecked Ship - Outside Wrecked Ship West - Door to Bowling Alley
                new ushort[] { 0xCE40, KeycardDoors.Left,       0x060E, KeycardEvents.WreckedShipLevel1,     KeycardPlaque.Level1,   0x040F, 0x0000 },  // Wrecked Ship - Gravity Suit - Door to Bowling Alley

                new ushort[] { 0xCC6F, KeycardDoors.Left,       0x064E, KeycardEvents.WreckedShipBoss,       KeycardPlaque.Boss,     0x044F, 0xC29D },  // Wrecked Ship - Pre-Phantoon - Door to Phantoon
            };

            ushort doorId = 0x0000;
            int plmTablePos = 0xf800;
            foreach (var door in doorList) {
                var doorArgs = door[4] != KeycardPlaque.None ? doorId | door[3] : door[3];
                if (door[6] == 0) {
                    // Write dynamic door
                    var doorData = door[0..3].SelectMany(x => UshortBytes(x)).Concat(UshortBytes(doorArgs)).ToArray();
                    patches.Add((Snes(0x8f0000 + plmTablePos), doorData));
                    plmTablePos += 0x08;
                } else {
                    // Overwrite existing door
                    var doorData = door[1..3].SelectMany(x => UshortBytes(x)).Concat(UshortBytes(doorArgs)).ToArray();
                    patches.Add((Snes(0x8f0000 + door[6]), doorData));
                    if((door[3] == KeycardEvents.BrinstarBoss && door[0] != 0x9D9C) || door[3] == KeycardEvents.LowerNorfairBoss || door[3] == KeycardEvents.MaridiaBoss || door[3] == KeycardEvents.WreckedShipBoss) {
                        // Overwrite the extra parts of the Gadora with a PLM that just deletes itself
                        patches.Add((Snes(0x8f0000 + door[6] + 0x06), new byte[] { 0x2F, 0xB6, 0x00, 0x00, 0x00, 0x00, 0x2F, 0xB6, 0x00, 0x00, 0x00, 0x00 }));
                    }
                }

                // Plaque data
                if (door[4] != KeycardPlaque.None) {
                    var plaqueData = UshortBytes(door[0]).Concat(UshortBytes(plaquePLm)).Concat(UshortBytes(door[5])).Concat(UshortBytes(door[4])).ToArray();
                    patches.Add((Snes(0x8f0000 + plmTablePos), plaqueData));
                    plmTablePos += 0x08;
                }
                doorId += 1;
            }

            patches.Add((Snes(0x8f0000 + plmTablePos), new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }));
        }

        int Snes(int addr) {
            addr = addr switch {
                /* Redirect hi bank $30 access into ExHiRom lo bank $40 */
                _ when (addr & 0xFF8000) == 0x308000 => 0x400000 | (addr & 0x7FFF),
                /* General case, add ExHi offset for banks < $80, and collapse mirroring */
                _ => (addr < 0x800000 ? 0x400000 : 0) | (addr & 0x3FFFFF),
            };
            if (addr > 0x600000)
                throw new InvalidOperationException($"Unmapped pc address target ${addr:X}");
            return addr;
        }

        byte[] UintBytes(int value)   => BitConverter.GetBytes((uint)value);
        byte[] UshortBytes(int value) => BitConverter.GetBytes((ushort)value);
        byte[] AsAscii(string text)   => Encoding.ASCII.GetBytes(text);

        int BeInt(byte[] bytes) => bytes.Select((x, i) => (x, i)).Aggregate(0, (t, n) => t | (n.x << (8 * (bytes.Length - n.i - 1))));

        byte[] AsCreditsString(int color, string text, bool alignLeft) {
            var creditsText = Regex.Replace(text.ToUpper(), "[^A-Z0-9\\.,'!: ]+", "");
            if (alignLeft) {
                creditsText = " " + creditsText[..Math.Min(creditsText.Length, 30)].PadRight(31, ' ');
            } else {
                creditsText = " " + creditsText[..Math.Min(creditsText.Length, 30)].PadLeft(30, '.') + " ";
            }

            return creditsText.Select(c => new byte[] {
                c switch { ' ' => 0x7f, '!' => 0x1f, ':' => 0x1e, '\'' => 0x1d, '_' => 0x1c, ',' => 0x1b, '.' => 0x1a, _ => (byte)(c - 0x41) },
                (byte)(c == ' ' ? 0x00 : color)
            }).SelectMany(x => x).ToArray();
        }

        #region "Save the animals" patch data
        static readonly Dictionary<string, byte[]> animalPatches = new Dictionary<string, byte[]> {
            ["Animals as Enemies"] = new byte [] {
                0x50, 0x41, 0x54, 0x43, 0x48, 0x07, 0x84, 0x18, 0x00, 0x06, 0x3B, 0xB6,
                0x00, 0x00, 0x1C, 0x8C, 0x07, 0x98, 0x61, 0x00, 0x07, 0xBB, 0x91, 0x12,
                0x84, 0x05, 0xB9, 0xBB, 0x10, 0x72, 0xD7, 0x00, 0x04, 0x01, 0x00, 0x58,
                0x02, 0x10, 0x72, 0xFB, 0x00, 0x02, 0x00, 0x00, 0x10, 0x73, 0x03, 0x00,
                0x03, 0x23, 0x80, 0x2D, 0x10, 0x73, 0x0F, 0x00, 0x0C, 0xC6, 0xEE, 0x00,
                0x00, 0x00, 0x0C, 0x44, 0xE9, 0x01, 0x00, 0x58, 0x02, 0x10, 0x73, 0x3B,
                0x00, 0x02, 0x00, 0x00, 0x10, 0x73, 0x43, 0x00, 0x03, 0x23, 0x80, 0x2D,
                0x10, 0x73, 0x4F, 0x00, 0x02, 0xC6, 0xEE, 0x10, 0x8E, 0xD5, 0x00, 0x08,
                0xDF, 0x00, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x20, 0x19, 0xE6, 0xE6, 0x00,
                0x01, 0xA0, 0x21, 0xE0, 0xDB, 0x00, 0x63, 0x00, 0x87, 0xD9, 0x06, 0x03,
                0xB3, 0x83, 0xB2, 0x83, 0x59, 0xFF, 0x00, 0x03, 0xB3, 0x83, 0xB3, 0x8B,
                0xDC, 0x20, 0x00, 0x8B, 0x43, 0x92, 0x83, 0xD9, 0x40, 0x05, 0x92, 0x83,
                0x40, 0x94, 0x0C, 0xC4, 0xD9, 0x60, 0x05, 0xB2, 0x83, 0x60, 0x94, 0x2C,
                0xD4, 0xDB, 0x80, 0x03, 0x60, 0x9C, 0x2C, 0xDC, 0xDB, 0x80, 0x02, 0x40,
                0x9C, 0x0C, 0xDA, 0x20, 0x00, 0xB2, 0x44, 0x83, 0x92, 0xDB, 0xA0, 0xF0,
                0x3F, 0x62, 0x00, 0x00, 0xAF, 0x5C, 0x83, 0xB0, 0x01, 0xB1, 0x83, 0xE4,
                0x3F, 0x80, 0xE4, 0x60, 0x00, 0x00, 0x41, 0x2E, 0x00, 0x00, 0xFF, 0x2E,
                0x00, 0x00, 0xFE, 0x2E, 0x00, 0x00, 0xFD, 0xE4, 0x6D, 0x00, 0x21, 0xE1,
                0x3F, 0x00, 0x00, 0x00, 0x2E, 0xFF, 0x45, 0x4F, 0x46
            },
            ["Animals has grey door"] = new byte [] {
                0x50, 0x41, 0x54, 0x43, 0x48, 0x07, 0x98, 0xD8, 0x00, 0x02, 0x00, 0xFC,
                0x07, 0xFC, 0x00, 0x00, 0x0E, 0x44, 0xDB, 0x08, 0x08, 0x10, 0x00, 0x42,
                0xC8, 0x2E, 0x06, 0xEE, 0x90, 0x00, 0x00, 0x07, 0xFD, 0x30, 0x00, 0x08,
                0xE3, 0xEE, 0x1D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x21, 0xE1, 0x86, 0x00,
                0x01, 0x06, 0x21, 0xE1, 0x8E, 0x00, 0x8F, 0xF8, 0x59, 0x60, 0x02, 0x8B,
                0xB2, 0x83, 0xF8, 0x5B, 0xC0, 0x07, 0x92, 0x83, 0x90, 0x83, 0x40, 0x94,
                0x0C, 0xC4, 0xF8, 0x57, 0xC0, 0x07, 0x0C, 0xC0, 0x40, 0x90, 0x60, 0x94,
                0x2C, 0xD4, 0xF8, 0x57, 0xC0, 0x07, 0x2C, 0xD0, 0x60, 0x90, 0x60, 0x9C,
                0x2C, 0xDC, 0xF8, 0x58, 0x60, 0x05, 0xD8, 0x60, 0x98, 0x40, 0x9C, 0x0C,
                0xF8, 0x58, 0x60, 0x03, 0x0C, 0xD8, 0x40, 0x98, 0x83, 0x22, 0x01, 0xF0,
                0x53, 0x22, 0x01, 0x83, 0x3E, 0x02, 0xC3, 0x04, 0xC5, 0x5E, 0xF8, 0x51,
                0x62, 0x83, 0x7E, 0x01, 0xC3, 0x04, 0xC7, 0xC0, 0xF8, 0x4F, 0xC4, 0x83,
                0xDE, 0x01, 0xC3, 0x04, 0x03, 0xAF, 0x82, 0xAD, 0x82, 0xF8, 0x5B, 0x04,
                0xE8, 0xBF, 0x44, 0x80, 0xE5, 0x20, 0x00, 0x00, 0x41, 0xE4, 0x2B, 0x00,
                0x03, 0x40, 0x01, 0x00, 0xFF, 0xE4, 0x2B, 0x00, 0x03, 0xFF, 0x01, 0x00,
                0xFE, 0xE4, 0x2B, 0x00, 0x03, 0xFE, 0x01, 0x00, 0xFD, 0xE4, 0x2B, 0x00,
                0x01, 0xFD, 0x01, 0xE5, 0x1F, 0x00, 0x21, 0xE2, 0x1D, 0x00, 0x00, 0x00,
                0x14, 0xFF, 0x45, 0x4F, 0x46
            },
            ["Animals have to be killed"] = new byte [] {
                0x50, 0x41, 0x54, 0x43, 0x48, 0x07, 0x84, 0x1D, 0x00, 0x01, 0x8C, 0x07,
                0x98, 0x61, 0x00, 0x07, 0xBB, 0x91, 0x12, 0x84, 0x05, 0xB9, 0xBB, 0x10,
                0x72, 0xD7, 0x00, 0x02, 0x01, 0x00, 0x10, 0x72, 0xFB, 0x00, 0x02, 0x00,
                0x00, 0x10, 0x73, 0x05, 0x00, 0x01, 0x2D, 0x10, 0x73, 0x17, 0x00, 0x02,
                0x01, 0x00, 0x10, 0x73, 0x3B, 0x00, 0x02, 0x00, 0x00, 0x10, 0x73, 0x45,
                0x00, 0x01, 0x2D, 0x10, 0x8E, 0xDC, 0x00, 0x01, 0x20, 0x19, 0xE6, 0xE6,
                0x00, 0x01, 0xA0, 0x21, 0xE0, 0xDB, 0x00, 0x63, 0x00, 0x87, 0xD9, 0x06,
                0x03, 0xB3, 0x83, 0xB2, 0x83, 0x59, 0xFF, 0x00, 0x03, 0xB3, 0x83, 0xB3,
                0x8B, 0xDC, 0x20, 0x00, 0x8B, 0x43, 0x92, 0x83, 0xD9, 0x40, 0x05, 0x92,
                0x83, 0x40, 0x94, 0x0C, 0xC4, 0xD9, 0x60, 0x05, 0xB2, 0x83, 0x60, 0x94,
                0x2C, 0xD4, 0xDB, 0x80, 0x03, 0x60, 0x9C, 0x2C, 0xDC, 0xDB, 0x80, 0x02,
                0x40, 0x9C, 0x0C, 0xDA, 0x20, 0x00, 0xB2, 0x44, 0x83, 0x92, 0xDB, 0xA0,
                0xF0, 0x3F, 0x62, 0x00, 0x00, 0xAF, 0x5C, 0x83, 0xB0, 0x01, 0xB1, 0x83,
                0xE4, 0x3F, 0x80, 0xE4, 0x60, 0x00, 0x00, 0x41, 0x2E, 0x00, 0x00, 0xFF,
                0x2E, 0x00, 0x00, 0xFE, 0x2E, 0x00, 0x00, 0xFD, 0xE4, 0x6D, 0x00, 0x21,
                0xE1, 0x3F, 0x00, 0x00, 0x00, 0x2E, 0xFF, 0x45, 0x4F, 0x46
            },
            ["Animals is Draygon"] = new byte[] {
                0x50, 0x41, 0x54, 0x43, 0x48, 0x01, 0xAD, 0xA0, 0x00, 0x24, 0xFD, 0x92,
                0x00, 0x05, 0x3E, 0x26, 0x03, 0x02, 0x00, 0x80, 0xA2, 0xB9, 0x60, 0xDA,
                0x40, 0x04, 0x01, 0x16, 0x00, 0x01, 0x00, 0x80, 0x00, 0x00, 0x79, 0x98,
                0x40, 0x05, 0x2E, 0x06, 0x02, 0x00, 0x00, 0x80, 0x00, 0x00, 0x07, 0x98,
                0xDC, 0x00, 0x02, 0x06, 0xF0, 0x07, 0xF0, 0x00, 0x00, 0x04, 0xA0, 0xAD,
                0xAC, 0xAD, 0x07, 0xF0, 0x06, 0x00, 0x12, 0xA9, 0x00, 0x00, 0x8F, 0x2C,
                0xD8, 0x7E, 0xA9, 0x00, 0xF0, 0x8F, 0xB5, 0x07, 0x7E, 0x5C, 0xBB, 0x91,
                0x8F, 0x07, 0xDA, 0x8A, 0x00, 0x02, 0x18, 0xF0, 0x07, 0xEF, 0xF0, 0x00,
                0x02, 0xB8, 0xAD, 0x07, 0xF0, 0x18, 0x00, 0x53, 0xAF, 0x20, 0xD8, 0x7E,
                0x89, 0x00, 0x40, 0xF0, 0x46, 0xA9, 0xF0, 0xEF, 0x8F, 0xB5, 0x07, 0x7E,
                0xA9, 0xFF, 0xFF, 0x8F, 0xD5, 0x1C, 0x7E, 0xA9, 0xAE, 0x80, 0x8F, 0xBE,
                0x01, 0x7F, 0xA9, 0xCE, 0x80, 0x8F, 0xFE, 0x01, 0x7F, 0xA9, 0xCE, 0x88,
                0x8F, 0x3E, 0x02, 0x7F, 0xA9, 0xAE, 0x88, 0x8F, 0x7E, 0x02, 0x7F, 0x08,
                0xE2, 0x20, 0xA9, 0x00, 0x8F, 0xC2, 0x66, 0x7F, 0x8F, 0xE2, 0x66, 0x7F,
                0x8F, 0x02, 0x67, 0x7F, 0x8F, 0x22, 0x67, 0x7F, 0xC2, 0x20, 0x28, 0x5C,
                0xDD, 0xC8, 0x8F, 0x5C, 0xDD, 0xC8, 0x8F, 0x45, 0x4F, 0x46
            },
            ["Animals is Ridley"] = new byte[] {
                0x50, 0x41, 0x54, 0x43, 0x48, 0x01, 0xAD, 0xA0, 0x00, 0x24, 0xFD, 0x92,
                0x00, 0x05, 0x3E, 0x26, 0x03, 0x02, 0x00, 0x80, 0xA2, 0xB9, 0x2E, 0xB3,
                0x40, 0x04, 0x01, 0x16, 0x00, 0x01, 0x00, 0x80, 0x00, 0x00, 0x79, 0x98,
                0x40, 0x05, 0x2E, 0x06, 0x02, 0x00, 0x00, 0x80, 0x00, 0x00, 0x07, 0x98,
                0xDC, 0x00, 0x02, 0x06, 0xF0, 0x07, 0xF0, 0x00, 0x00, 0x04, 0xA0, 0xAD,
                0xAC, 0xAD, 0x07, 0xF0, 0x06, 0x00, 0x12, 0xA9, 0x00, 0x00, 0x8F, 0x2A,
                0xD8, 0x7E, 0xA9, 0x00, 0xF0, 0x8F, 0xB5, 0x07, 0x7E, 0x5C, 0xBB, 0x91,
                0x8F, 0x07, 0xB3, 0x58, 0x00, 0x02, 0x18, 0xF0, 0x07, 0xEF, 0xF0, 0x00,
                0x02, 0xB8, 0xAD, 0x07, 0xF0, 0x18, 0x00, 0x42, 0xAF, 0x20, 0xD8, 0x7E,
                0x89, 0x00, 0x40, 0xF0, 0x35, 0xA9, 0x00, 0x00, 0x8F, 0xBB, 0xD8, 0x7E,
                0xA9, 0xF0, 0xEF, 0x8F, 0xB5, 0x07, 0x7E, 0xA9, 0xAA, 0xAA, 0x8F, 0xD5,
                0x1C, 0x7E, 0xA9, 0xAE, 0x80, 0x8F, 0xDE, 0x00, 0x7F, 0xA9, 0xCE, 0x80,
                0x8F, 0xFE, 0x00, 0x7F, 0xA9, 0xCE, 0x88, 0x8F, 0x1E, 0x01, 0x7F, 0xA9,
                0xAE, 0x88, 0x8F, 0x3E, 0x01, 0x7F, 0x5C, 0xF7, 0x91, 0x8F, 0x5C, 0xF7,
                0x91, 0x8F, 0x45, 0x4F, 0x46
            },
            ["Animals is Phantoon"] = new byte[] {
                0x50, 0x41, 0x54, 0x43, 0x48, 0x01, 0xAD, 0xA0, 0x00, 0x24, 0xFD, 0x92,
                0x00, 0x05, 0x3E, 0x26, 0x03, 0x02, 0x00, 0x80, 0xA2, 0xB9, 0x13, 0xCD,
                0x40, 0x04, 0x01, 0x06, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x79, 0x98,
                0x40, 0x05, 0x2E, 0x06, 0x02, 0x00, 0x00, 0x80, 0x00, 0x00, 0x07, 0x98,
                0xDC, 0x00, 0x02, 0x06, 0xF0, 0x07, 0xF0, 0x00, 0x00, 0x04, 0xA0, 0xAD,
                0xAC, 0xAD, 0x07, 0xF0, 0x06, 0x00, 0x12, 0xA9, 0x00, 0x00, 0x8F, 0x2B,
                0xD8, 0x7E, 0xA9, 0x00, 0xF0, 0x8F, 0xB5, 0x07, 0x7E, 0x5C, 0xBB, 0x91,
                0x8F, 0x07, 0xCD, 0x3D, 0x00, 0x02, 0x18, 0xF0, 0x07, 0xEF, 0xF0, 0x00,
                0x02, 0xB8, 0xAD, 0x07, 0xF0, 0x18, 0x00, 0x1F, 0xAF, 0x20, 0xD8, 0x7E,
                0x89, 0x00, 0x40, 0xF0, 0x12, 0xA9, 0x00, 0x00, 0x8F, 0xC0, 0xD8, 0x7E,
                0xA9, 0xF0, 0xEF, 0x8F, 0xB5, 0x07, 0x7E, 0x5C, 0xD0, 0xC8, 0x8F, 0x5C,
                0xD0, 0xC8, 0x8F, 0x45, 0x4F, 0x46
            },
            ["Animals is Metal Pirates"] = new byte[] {
                0x50, 0x41, 0x54, 0x43, 0x48, 0x01, 0xAD, 0xA0, 0x00, 0x24, 0xFD, 0x92,
                0x00, 0x05, 0x3E, 0x26, 0x03, 0x02, 0x00, 0x80, 0xA2, 0xB9, 0x2B, 0xB6,
                0x40, 0x04, 0x01, 0x06, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x79, 0x98,
                0x40, 0x05, 0x2E, 0x06, 0x02, 0x00, 0x00, 0x80, 0x00, 0x00, 0x07, 0x98,
                0xDC, 0x00, 0x02, 0x06, 0xF0, 0x07, 0xF0, 0x00, 0x00, 0x04, 0xA0, 0xAD,
                0xAC, 0xAD, 0x07, 0xF0, 0x06, 0x00, 0x0B, 0xA9, 0x00, 0xF0, 0x8F, 0xB5,
                0x07, 0x7E, 0x5C, 0xBB, 0x91, 0x8F, 0x07, 0xB6, 0x50, 0x00, 0x02, 0x18,
                0xF0, 0x07, 0xEF, 0xF0, 0x00, 0x04, 0xB8, 0xAD, 0xAC, 0xAD, 0x07, 0xF0,
                0x18, 0x00, 0x1C, 0xAF, 0x20, 0xD8, 0x7E, 0x89, 0x00, 0x40, 0xF0, 0x12,
                0xA9, 0x00, 0x00, 0x8F, 0xBC, 0xD8, 0x7E, 0xA9, 0xF0, 0xEF, 0x8F, 0xB5,
                0x07, 0x7E, 0x5C, 0xF7, 0x91, 0x8F, 0x60, 0x45, 0x4F, 0x46
            },
            ["Animals is back to escape"] = new byte[] {
                0x50, 0x41, 0x54, 0x43, 0x48, 0x01, 0xAD, 0xA0, 0x00, 0x18, 0xFD, 0x92,
                0x00, 0x05, 0x3E, 0x26, 0x03, 0x02, 0x00, 0x80, 0xA2, 0xB9, 0x4D, 0xDE,
                0x40, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 0x00, 0x00, 0x07, 0x98,
                0xDC, 0x00, 0x02, 0x06, 0xF0, 0x07, 0xF0, 0x00, 0x00, 0x04, 0xA0, 0xAD,
                0xAC, 0xAD, 0x07, 0xF0, 0x06, 0x00, 0x0B, 0xA9, 0x00, 0xF0, 0x8F, 0xB5,
                0x07, 0x7E, 0x5C, 0xBB, 0x91, 0x8F, 0x45, 0x4F, 0x46
            },
            ["Animals ends game"] = new byte[] {
                0x50, 0x41, 0x54, 0x43, 0x48, 0x01, 0x8B, 0xCC, 0x00, 0x02, 0x20, 0xFF,
                0x07, 0xFF, 0x20, 0x00, 0x11, 0xAF, 0x20, 0xD8, 0x7E, 0x89, 0x00, 0x40,
                0xF0, 0x07, 0xA9, 0x26, 0x00, 0x8F, 0x98, 0x09, 0x7E, 0x60, 0x45, 0x4F,
                0x46
            },
            ["Animals sets the timer low"] = new byte[] {
                0x50, 0x41, 0x54, 0x43, 0x48, 0x01, 0x8B, 0xCC, 0x00, 0x02, 0x20, 0xFF,
                0x07, 0xFF, 0x20, 0x00, 0x11, 0xAF, 0x20, 0xD8, 0x7E, 0x89, 0x00, 0x40,
                0xF0, 0x07, 0xA9, 0x20, 0x00, 0x8F, 0x46, 0x09, 0x7E, 0x60, 0x45, 0x4F,
                0x46
            }
        };

        private void ApplyIps(byte[] ipsData) {
            using var br = new BinaryReader(new MemoryStream(ipsData));

            var patch = new string(br.ReadChars(5));
            if (patch != "PATCH") {
                throw new InvalidDataException("The argument data is not an IPS patch.");
            }

            var chunkHeader = br.ReadBytes(3);
            while (!(chunkHeader[0] == 'E' && chunkHeader[1] == 'O' && chunkHeader[2] == 'F')) {
                var offset = BeInt(chunkHeader);
                var length = BeInt(br.ReadBytes(2));

                if(length > 0) {
                    patches.Add((offset, br.ReadBytes(length)));
                } else {
                    var runLength = BeInt(br.ReadBytes(2));
                    byte runByte = br.ReadByte();
                    patches.Add((offset, Enumerable.Repeat(runByte, runLength).ToArray()));
                }

                chunkHeader = br.ReadBytes(3);
            }
        }

        void WriteAnimalSurprise() {
            ApplyIps(animalPatches.Values.ElementAt(rnd.Next(animalPatches.Count - 1)));
        }

        #endregion
    }
}
